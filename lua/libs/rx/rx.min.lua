-- RxLua v0.0.2
-- https://github.com/bjornbytes/rxlua
-- MIT License

local a={}a.pack=table.pack or function(...)return{n=select('#',...),...}end;a.unpack=table.unpack or unpack;a.eq=function(b,c)return b==c end;a.noop=function()end;a.identity=function(b)return b end;a.constant=function(b)return function()return b end end;a.isa=function(d,e)return type(d)=='table'and getmetatable(d).__index==e end;a.tryWithObserver=function(f,g,...)local h,i=pcall(g,...)if not h then f:onError(i)end;return h,i end;local j={}j.__index=j;j.__tostring=a.constant('Subscription')function j.create(k)local self={action=k or a.noop,unsubscribed=false}return setmetatable(self,j)end;function j:unsubscribe()if self.unsubscribed then return end;self.action(self)self.unsubscribed=true end;local l={}l.__index=l;l.__tostring=a.constant('Observer')function l.create(m,n,o)local self={_onNext=m or a.noop,_onError=n or error,_onCompleted=o or a.noop,stopped=false}return setmetatable(self,l)end;function l:onNext(...)if not self.stopped then self._onNext(...)end end;function l:onError(p)if not self.stopped then self.stopped=true;self._onError(p)end end;function l:onCompleted()if not self.stopped then self.stopped=true;self._onCompleted()end end;local q={}q.__index=q;q.__tostring=a.constant('Observable')function q.create(r)local self={_subscribe=r}return setmetatable(self,q)end;function q:subscribe(m,n,o)if type(m)=='table'then return self._subscribe(m)else return self._subscribe(l.create(m,n,o))end end;function q.empty()return q.create(function(f)f:onCompleted()end)end;function q.never()return q.create(function(f)end)end;function q.throw(p)return q.create(function(f)f:onError(p)end)end;function q.of(...)local s={...}local t=select('#',...)return q.create(function(f)for u=1,t do f:onNext(s[u])end;f:onCompleted()end)end;function q.fromRange(v,w,x)if not w and not x then v,w=1,v end;x=x or 1;return q.create(function(f)for u=v,w,x do f:onNext(u)end;f:onCompleted()end)end;function q.fromTable(y,z,A)z=z or pairs;return q.create(function(f)for B,C in z(y)do f:onNext(C,A and B or nil)end;f:onCompleted()end)end;function q.fromCoroutine(g,D)return q.create(function(f)local E=type(g)=='function'and coroutine.create(g)or g;return D:schedule(function()while not f.stopped do local h,C=coroutine.resume(E)if h then f:onNext(C)else return f:onError(C)end;if coroutine.status(E)=='dead'then return f:onCompleted()end;coroutine.yield()end end)end)end;function q.fromFileByLine(F)return q.create(function(f)local G=io.open(F,'r')if G then G:close()for H in io.lines(F)do f:onNext(H)end;return f:onCompleted()else return f:onError(F)end end)end;function q.defer(g)return setmetatable({subscribe=function(I,...)local J=g()return J:subscribe(...)end},q)end;function q.replicate(C,K)return q.create(function(f)while K==nil or K>0 do f:onNext(C)if K then K=K-1 end end;f:onCompleted()end)end;function q:dump(L,M)L=L and L..' 'or''M=M or tostring;local m=function(...)print(L..'onNext: '..M(...))end;local n=function(N)print(L..'onError: '..N)end;local o=function()print(L..'onCompleted')end;return self:subscribe(m,n,o)end;function q:all(O)O=O or a.identity;return q.create(function(f)local function m(...)a.tryWithObserver(f,function(...)if not O(...)then f:onNext(false)f:onCompleted()end end,...)end;local function n(N)return f:onError(N)end;local function o()f:onNext(true)return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q.amb(P,Q,...)if not P or not Q then return P end;return q.create(function(f)local R,S;local function T(...)if S then S:unsubscribe()end;f:onNext(...)end;local function U(N)if S then S:unsubscribe()end;f:onError(N)end;local function V()if S then S:unsubscribe()end;f:onCompleted()end;local function W(...)if R then R:unsubscribe()end;f:onNext(...)end;local function X(N)if R then R:unsubscribe()end;f:onError(N)end;local function Y()if R then R:unsubscribe()end;f:onCompleted()end;R=P:subscribe(T,U,V)S=Q:subscribe(W,X,Y)return j.create(function()R:unsubscribe()S:unsubscribe()end)end):amb(...)end;function q:average()return q.create(function(f)local Z,K=0,0;local function m(C)Z=Z+C;K=K+1 end;local function n(N)f:onError(N)end;local function o()if K>0 then f:onNext(Z/K)end;f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:buffer(_)return q.create(function(f)local a0={}local function a1()if#a0>0 then f:onNext(a.unpack(a0))a0={}end end;local function m(...)local a2={...}for u=1,#a2 do table.insert(a0,a2[u])if#a0>=_ then a1()end end end;local function n(p)a1()return f:onError(p)end;local function o()a1()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:catch(a3)a3=a3 and(type(a3)=='function'and a3 or a.constant(a3))return q.create(function(f)local a4;local function m(...)return f:onNext(...)end;local function n(N)if not a3 then return f:onCompleted()end;local h,a5=pcall(a3,N)if h and a5 then if a4 then a4:unsubscribe()end;a5:subscribe(f)else f:onError(h and N or a5)end end;local function o()f:onCompleted()end;a4=self:subscribe(m,n,o)return a4 end)end;function q:combineLatest(...)local a6={...}local a7=table.remove(a6)if type(a7)~='function'then table.insert(a6,a7)a7=function(...)return...end end;table.insert(a6,1,self)return q.create(function(f)local a8={}local a9={a.unpack(a6)}local aa={}local function m(u)return function(C)a8[u]=C;a9[u]=nil;if not next(a9)then a.tryWithObserver(f,function()f:onNext(a7(a.unpack(a8)))end)end end end;local function n(N)return f:onError(N)end;local function o(u)return function()table.insert(aa,u)if#aa==#a6 then f:onCompleted()end end end;for u=1,#a6 do a6[u]:subscribe(m(u),n,o(u))end end)end;function q:compact()return self:filter(a.identity)end;function q:concat(ab,...)if not ab then return self end;local ac={...}return q.create(function(f)local function m(...)return f:onNext(...)end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;local function ad()return ab:concat(a.unpack(ac)):subscribe(m,n,o)end;return self:subscribe(m,n,ad)end)end;function q:contains(C)return q.create(function(f)local a4;local function m(...)local s=a.pack(...)if#s==0 and C==nil then f:onNext(true)if a4 then a4:unsubscribe()end;return f:onCompleted()end;for u=1,#s do if s[u]==C then f:onNext(true)if a4 then a4:unsubscribe()end;return f:onCompleted()end end end;local function n(N)return f:onError(N)end;local function o()f:onNext(false)return f:onCompleted()end;a4=self:subscribe(m,n,o)return a4 end)end;function q:count(O)O=O or a.constant(true)return q.create(function(f)local K=0;local function m(...)a.tryWithObserver(f,function(...)if O(...)then K=K+1 end end,...)end;local function n(N)return f:onError(N)end;local function o()f:onNext(K)f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:debounce(ae,D)ae=ae or 0;return q.create(function(f)local af={}local function ag(B)return function(...)local C=a.pack(...)if af[B]then af[B]:unsubscribe()end;local a2=a.pack(...)af[B]=D:schedule(function()return f[B](f,a.unpack(a2))end,ae)end end;local a4=self:subscribe(ag('onNext'),ag('onError'),ag('onCompleted'))return j.create(function()if a4 then a4:unsubscribe()end;for I,ah in pairs(af)do ah:unsubscribe()end end)end)end;function q:defaultIfEmpty(...)local ai=a.pack(...)return q.create(function(f)local aj=false;local function m(...)aj=true;f:onNext(...)end;local function n(N)f:onError(N)end;local function o()if not aj then f:onNext(a.unpack(ai))end;f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:delay(ae,D)ae=type(ae)~='function'and a.constant(ae)or ae;return q.create(function(f)local ak={}local function al(B)return function(...)local am=a.pack(...)local an=D:schedule(function()f[B](f,a.unpack(am))end,ae())table.insert(ak,an)end end;local a4=self:subscribe(al('onNext'),al('onError'),al('onCompleted'))return j.create(function()if a4 then a4:unsubscribe()end;for u=1,#ak do ak[u]:unsubscribe()end end)end)end;function q:distinct()return q.create(function(f)local a2={}local function m(b)if not a2[b]then f:onNext(b)end;a2[b]=true end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:distinctUntilChanged(ao)ao=ao or a.eq;return q.create(function(f)local ap=true;local aq=nil;local function m(C,...)local a2=a.pack(...)a.tryWithObserver(f,function()if ap or not ao(C,aq)then f:onNext(C,a.unpack(a2))aq=C;ap=false end end)end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:elementAt(ar)return q.create(function(f)local a4;local u=1;local function m(...)if u==ar then f:onNext(...)f:onCompleted()if a4 then a4:unsubscribe()end else u=u+1 end end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;a4=self:subscribe(m,n,o)return a4 end)end;function q:filter(O)O=O or a.identity;return q.create(function(f)local function m(...)a.tryWithObserver(f,function(...)if O(...)then return f:onNext(...)end end,...)end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:find(O)O=O or a.identity;return q.create(function(f)local function m(...)a.tryWithObserver(f,function(...)if O(...)then f:onNext(...)return f:onCompleted()end end,...)end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:first()return self:take(1)end;function q:flatMap(as)as=as or a.identity;return self:map(as):flatten()end;function q:flatMapLatest(as)as=as or a.identity;return q.create(function(f)local at;local function m(...)f:onNext(...)end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;local function au(...)if at then at:unsubscribe()end;return a.tryWithObserver(f,function(...)at=as(...):subscribe(m,n)end,...)end;local a4=self:subscribe(au,n,o)return j.create(function()if at then at:unsubscribe()end;if a4 then a4:unsubscribe()end end)end)end;function q:flatten()return q.create(function(f)local function n(p)return f:onError(p)end;local function m(J)local function av(...)f:onNext(...)end;J:subscribe(av,n,a.noop)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:ignoreElements()return q.create(function(f)local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;return self:subscribe(nil,n,o)end)end;function q:last()return q.create(function(f)local C;local aw=true;local function m(...)C={...}aw=false end;local function n(N)return f:onError(N)end;local function o()if not aw then f:onNext(a.unpack(C or{}))end;return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:map(as)return q.create(function(f)as=as or a.identity;local function m(...)return a.tryWithObserver(f,function(...)return f:onNext(as(...))end,...)end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:max()return self:reduce(math.max)end;function q:merge(...)local a6={...}table.insert(a6,1,self)return q.create(function(f)local function m(...)return f:onNext(...)end;local function n(p)return f:onError(p)end;local function o(u)return function()a6[u]=nil;if not next(a6)then f:onCompleted()end end end;for u=1,#a6 do a6[u]:subscribe(m,n,o(u))end end)end;function q:min()return self:reduce(math.min)end;function q:pack()return self:map(a.pack)end;function q:partition(O)return self:filter(O),self:reject(O)end;function q:pluck(B,...)if not B then return self end;if type(B)~='string'and type(B)~='number'then return q.throw('pluck key must be a string')end;return q.create(function(f)local function m(y)return f:onNext(y[B])end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end):pluck(...)end;function q:reduce(ax,ay)return q.create(function(f)local i=ay;local ap=true;local function m(...)if ap and ay==nil then i=...ap=false else return a.tryWithObserver(f,function(...)i=ax(i,...)end,...)end end;local function n(N)return f:onError(N)end;local function o()f:onNext(i)return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:reject(O)O=O or a.identity;return q.create(function(f)local function m(...)a.tryWithObserver(f,function(...)if not O(...)then return f:onNext(...)end end,...)end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:retry(K)return q.create(function(f)local a4;local az=0;local function m(...)return f:onNext(...)end;local function o()return f:onCompleted()end;local function n(p)if a4 then a4:unsubscribe()end;az=az+1;if K and az>K then return f:onError(p)end;a4=self:subscribe(m,n,o)end;return self:subscribe(m,n,o)end)end;function q:sample(aA)if not aA then error('Expected an Observable')end;return q.create(function(f)local a8={}local function aB(...)a8=a.pack(...)end;local function m()return f:onNext(a.unpack(a8))end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;local aC=self:subscribe(aB,n)local aD=aA:subscribe(m,n,o)return j.create(function()if aC then aC:unsubscribe()end;if aD then aD:unsubscribe()end end)end)end;function q:scan(ax,ay)return q.create(function(f)local i=ay;local ap=true;local function m(...)if ap and ay==nil then i=...ap=false else return a.tryWithObserver(f,function(...)i=ax(i,...)f:onNext(i)end,...)end end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:skip(aE)aE=aE or 1;return q.create(function(f)local u=1;local function m(...)if u>aE then f:onNext(...)else u=u+1 end end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:skipLast(K)local a0={}return q.create(function(f)local function a1()if#a0>K and a0[1]then local a2=table.remove(a0,1)f:onNext(a.unpack(a2))end end;local function m(...)a1()table.insert(a0,a.pack(...))end;local function n(p)return f:onError(p)end;local function o()a1()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:skipUntil(ab)return q.create(function(f)local aF=false;local function aG()aF=true end;ab:subscribe(aG,aG,aG)local function m(...)if aF then f:onNext(...)end end;local function n()if aF then f:onError()end end;local function o()if aF then f:onCompleted()end end;return self:subscribe(m,n,o)end)end;function q:skipWhile(O)O=O or a.identity;return q.create(function(f)local aH=true;local function m(...)if aH then a.tryWithObserver(f,function(...)aH=O(...)end,...)end;if not aH then return f:onNext(...)end end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:startWith(...)local a2=a.pack(...)return q.create(function(f)f:onNext(a.unpack(a2))return self:subscribe(f)end)end;function q:sum()return self:reduce(function(b,c)return b+c end,0)end;function q:switch()return q.create(function(f)local a4;local function m(...)return f:onNext(...)end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;local function aI(aJ)if a4 then a4:unsubscribe()end;a4=aJ:subscribe(m,n,nil)end;return self:subscribe(aI,n,o)end)end;function q:take(aE)aE=aE or 1;return q.create(function(f)if aE<=0 then f:onCompleted()return end;local u=1;local function m(...)f:onNext(...)u=u+1;if u>aE then f:onCompleted()end end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:takeLast(K)return q.create(function(f)local a0={}local function m(...)table.insert(a0,a.pack(...))if#a0>K then table.remove(a0,1)end end;local function n(p)return f:onError(p)end;local function o()for u=1,#a0 do f:onNext(a.unpack(a0[u]))end;return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:takeUntil(ab)return q.create(function(f)local function m(...)return f:onNext(...)end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;ab:subscribe(o,o,o)return self:subscribe(m,n,o)end)end;function q:takeWhile(O)O=O or a.identity;return q.create(function(f)local aK=true;local function m(...)if aK then a.tryWithObserver(f,function(...)aK=O(...)end,...)if aK then return f:onNext(...)else return f:onCompleted()end end end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:tap(aL,aM,aN)aL=aL or a.noop;aM=aM or a.noop;aN=aN or a.noop;return q.create(function(f)local function m(...)a.tryWithObserver(f,function(...)aL(...)end,...)return f:onNext(...)end;local function n(p)a.tryWithObserver(f,function()aM(p)end)return f:onError(p)end;local function o()a.tryWithObserver(f,function()aN()end)return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:unpack()return self:map(a.unpack)end;function q:unwrap()return q.create(function(f)local function m(...)local a2={...}for u=1,#a2 do f:onNext(a2[u])end end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:window(_)return q.create(function(f)local aO={}local function m(C)table.insert(aO,C)if#aO>=_ then f:onNext(a.unpack(aO))table.remove(aO,1)end end;local function n(p)return f:onError(p)end;local function o()return f:onCompleted()end;return self:subscribe(m,n,o)end)end;function q:with(...)local a6={...}return q.create(function(f)local a8=setmetatable({},{__len=a.constant(#a6)})local function aB(u)return function(C)a8[u]=C end end;local function m(C)return f:onNext(C,a.unpack(a8))end;local function n(N)return f:onError(N)end;local function o()return f:onCompleted()end;for u=1,#a6 do a6[u]:subscribe(aB(u),a.noop,a.noop)end;return self:subscribe(m,n,o)end)end;function q.zip(...)local a6=a.pack(...)local K=#a6;return q.create(function(f)local a2={}local aP={}for u=1,K do a2[u]={n=0}aP[u]=true end;local function m(u)return function(C)table.insert(a2[u],C)a2[u].n=a2[u].n+1;local aQ=true;for u=1,K do if a2[u].n==0 then aQ=false;break end end;if aQ then local aR={}for u=1,K do aR[u]=table.remove(a2[u],1)a2[u].n=a2[u].n-1 end;f:onNext(a.unpack(aR))end end end;local function n(p)return f:onError(p)end;local function o(u)return function()aP[u]=nil;if not next(aP)or a2[u].n==0 then return f:onCompleted()end end end;for u=1,K do a6[u]:subscribe(m(u),n,o(u))end end)end;local aS={}aS.__index=aS;aS.__tostring=a.constant('ImmediateScheduler')function aS.create()return setmetatable({},aS)end;function aS:schedule(k)k()end;local aT={}aT.__index=aT;aT.__tostring=a.constant('CooperativeScheduler')function aT.create(aU)local self={tasks={},currentTime=aU or 0}return setmetatable(self,aT)end;function aT:schedule(k,al)local aV={thread=coroutine.create(k),due=self.currentTime+(al or 0)}table.insert(self.tasks,aV)return j.create(function()return self:unschedule(aV)end)end;function aT:unschedule(aV)for u=1,#self.tasks do if self.tasks[u]==aV then table.remove(self.tasks,u)end end end;function aT:update(aW)self.currentTime=self.currentTime+(aW or 0)for u=#self.tasks,1,-1 do local aV=self.tasks[u]if self.currentTime>=aV.due then local h,al=coroutine.resume(aV.thread)if coroutine.status(aV.thread)=='dead'then table.remove(self.tasks,u)else aV.due=math.max(aV.due+(al or 0),self.currentTime)end;if not h then error(al)end end end end;function aT:isEmpty()return not next(self.tasks)end;local aX={}aX.__index=aX;aX.__tostring=a.constant('TimeoutScheduler')function aX.create()return setmetatable({},aX)end;function aX:schedule(k,al,...)local aY=require'timer'local a4;local an=aY.setTimeout(al,k,...)return j.create(function()aY.clearTimeout(an)end)end;local aZ=setmetatable({},q)aZ.__index=aZ;aZ.__tostring=a.constant('Subject')function aZ.create()local self={observers={},stopped=false}return setmetatable(self,aZ)end;function aZ:subscribe(m,n,o)local f;if a.isa(m,l)then f=m else f=l.create(m,n,o)end;table.insert(self.observers,f)return j.create(function()for u=1,#self.observers do if self.observers[u]==f then table.remove(self.observers,u)return end end end)end;function aZ:onNext(...)if not self.stopped then for u=1,#self.observers do self.observers[u]:onNext(...)end end end;function aZ:onError(p)if not self.stopped then for u=1,#self.observers do self.observers[u]:onError(p)end;self.stopped=true end end;function aZ:onCompleted()if not self.stopped then for u=1,#self.observers do self.observers[u]:onCompleted()end;self.stopped=true end end;aZ.__call=aZ.onNext;local a_=setmetatable({},q)a_.__index=a_;a_.__tostring=a.constant('AsyncSubject')function a_.create()local self={observers={},stopped=false,value=nil,errorMessage=nil}return setmetatable(self,a_)end;function a_:subscribe(m,n,o)local f;if a.isa(m,l)then f=m else f=l.create(m,n,o)end;if self.value then f:onNext(a.unpack(self.value))f:onCompleted()return elseif self.errorMessage then f:onError(self.errorMessage)return end;table.insert(self.observers,f)return j.create(function()for u=1,#self.observers do if self.observers[u]==f then table.remove(self.observers,u)return end end end)end;function a_:onNext(...)if not self.stopped then self.value=a.pack(...)end end;function a_:onError(p)if not self.stopped then self.errorMessage=p;for u=1,#self.observers do self.observers[u]:onError(self.errorMessage)end;self.stopped=true end end;function a_:onCompleted()if not self.stopped then for u=1,#self.observers do if self.value then self.observers[u]:onNext(a.unpack(self.value))end;self.observers[u]:onCompleted()end;self.stopped=true end end;a_.__call=a_.onNext;local b0=setmetatable({},aZ)b0.__index=b0;b0.__tostring=a.constant('BehaviorSubject')function b0.create(...)local self={observers={},stopped=false}if select('#',...)>0 then self.value=a.pack(...)end;return setmetatable(self,b0)end;function b0:subscribe(m,n,o)local f;if a.isa(m,l)then f=m else f=l.create(m,n,o)end;local a4=aZ.subscribe(self,f)if self.value then f:onNext(a.unpack(self.value))end;return a4 end;function b0:onNext(...)self.value=a.pack(...)return aZ.onNext(self,...)end;function b0:getValue()if self.value~=nil then return a.unpack(self.value)end end;b0.__call=b0.onNext;local b1=setmetatable({},aZ)b1.__index=b1;b1.__tostring=a.constant('ReplaySubject')function b1.create(aE)local self={observers={},stopped=false,buffer={},bufferSize=aE}return setmetatable(self,b1)end;function b1:subscribe(m,n,o)local f;if a.isa(m,l)then f=m else f=l.create(m,n,o)end;local a4=aZ.subscribe(self,f)for u=1,#self.buffer do f:onNext(a.unpack(self.buffer[u]))end;return a4 end;function b1:onNext(...)table.insert(self.buffer,a.pack(...))if self.bufferSize and#self.buffer>self.bufferSize then table.remove(self.buffer,1)end;return aZ.onNext(self,...)end;b1.__call=b1.onNext;q.wrap=q.buffer;q['repeat']=q.replicate;return{util=a,Subscription=j,Observer=l,Observable=q,ImmediateScheduler=aS,CooperativeScheduler=aT,TimeoutScheduler=aX,Subject=aZ,AsyncSubject=a_,BehaviorSubject=b0,ReplaySubject=b1}